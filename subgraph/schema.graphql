type Vault @entity {
  id: Bytes!
  "The token that this vault is for"
  token: Bytes!
  "The owner of this vault"
  owner: Bytes!
  "The vaultId of this vault"
  vaultId: BigInt!
  "The amount of the token that is in this vault"
  balance: BigInt!
  "All balance changes for this vault"
  balanceChanges: [VaultBalanceChange!]! @derivedFrom(field: "vault")
}

interface VaultBalanceChange {
  "The vault that was affected"
  vault: Vault!
  "The amount that was changed - this is unsigned"
  amount: BigInt!
  "The balance of the vault before the change"
  oldBalance: BigInt!
  "The balance of the vault after the change"
  newBalance: BigInt!
}

type Deposit implements Event & VaultBalanceChange @entity(immutable: true) {
  id: Bytes!
  "The token that was deposited"
  token: Bytes!
  "The vault that was deposited into"
  vault: Vault!
  "The amount that was deposited"
  amount: BigInt!

  # For VaultBalanceChange
  oldBalance: BigInt!
  newBalance: BigInt!

  # For Event
  transaction: Transaction!
  "The msg.sender of this withdrawal"
  sender: Bytes!
}

type Withdrawal implements Event & VaultBalanceChange @entity(immutable: true) {
  id: Bytes!
  "The token that was withdrawn"
  token: Bytes!
  "The vault that was withdrawn from"
  vault: Vault!
  "The amount that was being targeted to be withdrawn"
  targetAmount: BigInt!
  "The amount that was actually withdrawn"
  amount: BigInt!

  # For VaultBalanceChange
  oldBalance: BigInt!
  newBalance: BigInt!

  # For Event
  transaction: Transaction!
  "The msg.sender of this withdrawal"
  sender: Bytes!
}

type Transaction @entity(immutable: true) {
  id: Bytes!
  timestamp: BigInt!
  blockNumber: BigInt!
  from: Bytes!
  events: [Event!] @derivedFrom(field: "transaction")
}

interface Event {
  "Transaction this event was emitted in"
  transaction: Transaction!
  "msg.sender for the event"
  sender: Bytes!
}